---
{"dg-publish":true,"title":"JavaScript에서  대규모 숫자의 경우 스프레드 연산자가 실패하는 이유를 분석하고 테스트해보며 stack size 이해하기","description":" 스프레드 연산자의 크기가 너무 커지는 경우 동일한 로직이더라도 문제가 생기는 특수한 경우를 알아보고 해결해봅시다.","permalink":"/projects/library/kr/000/010/010-30/kr-010-40-b/","dgPassFrontmatter":true,"noteIcon":"0","created":"2025-04-08T23:58:41.463+09:00","updated":"2025-04-09T14:30:16.645+09:00"}
---

현재 노트: [[Projects/Library/KR/000/010/010.30/KR-010.40 b\|KR-010.40 b]] 
상위 분류: [[Projects/Library/KR/000/010/010.40/KR-010.40\|KR-010.40]] 

#JavaScript


# Why? 왜 이 글을 쓰게 되었나요?
JavaScript에서 당연하게 사용하던 스프레드연산자가  배열크기로 인해 런타임에러가 발생하였습니다.
단순히 다루는 수의 크기가 커지는 것만으로 발생할 수 있는 문제라는 점이 신선했었고, JavaScript를 깊게 이해하기 위한 부분이라 생각하여 트러블슈팅과 테스트 과정을 글로 작성하기로 했습니다.


# What? 어떤 문제가 있었나요?


프로그래머스 [퍼즐챌린지](https://school.programmers.co.kr/learn/courses/30/lessons/340212)를 풀 던 도중 런타임 에러가 자꾸발생하였습니다.
런타엠 에러라길래 보통의 배열의 잘못된 인덱스 접근인줄 알고 로직으로 해결하려고하였으나, 계속 에러가 생겨서 포기하였습니다.
그래서 질문하기 코너를 찾아보았는데 그 중에 [해당 문제를 언급한 글](https://school.programmers.co.kr/questions/80164)이 있었습니다.

런타임 에러의 원인은 **스프레드 연산자의 배열크기** 때문이라는 것.



# How 어떻게 해결하셨나요?

그래서 코드를 스프레드연산자가아니라 forEach로 하나씩 꺼내서 사용하는 형태로 구성하니 문제를 해결할 수 있었습니다.

하지만 여기서 더 나아가 **"스프레드 연산자 배열의 최대 크기"** 를 구해보면 어떨까 하는 생각에 테스트를 수행해보았습니다.고 30만 배열의 크기일지라도 문제없이 동작하였습니다!
`$ node --stack-size=4000 callstackSize.js `

![](https://i.imgur.com/QRah4Fw.png)







# Retrospective 무엇을 배웠고, 어떻게 활용할까요?
가장 중요한 부분은 숫자가 커지는 것만으로 문제가 발생할 수 있는상황을 깨달은 점입니다.
흔히 대규모 트래픽과 같은 경우 기존의 아키텍처, 로직으로 감당히 불가능한 상황이 나오는 것으로 알고있습니다. 그런 상황을 이번 트러블 슈팅을 통해 느꼈습니다.



물론 추가적으로 stack의 사이즈를 직접 조사하는 방법과 그 크기를 예상하는 방법 등 좀 더 깊은레벨의  JavaScript 정확히는 Node.js의 구조를  이해하게됐습니다.









